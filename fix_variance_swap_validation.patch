--- a/strategies/options/variance_swap_strategy.py
+++ b/strategies/options/variance_swap_strategy.py
@@ -486,6 +486,77 @@ class VarianceSwapStrategy(BaseOptionsStrategy):
         return True
     # - ENDMOCK -
     
+    def _validate_basic_inputs(self, polymarket_contract: Dict, current_spot: float) -> bool:
+        """
+        Validate only the basic required inputs without price thresholds.
+        This checks for required fields and valid spot price only.
+        
+        Returns:
+            True if basic inputs are valid, False otherwise
+        """
+        # Check required fields
+        reason = None
+        missing = None
+        for field in self.REQUIRED_FIELDS:
+            if field not in polymarket_contract:
+                self.logger.debug(f"Missing required field: {field}")
+                missing = field
+                reason = f"MISSING_{field.upper()}"
+                _audit_emit({
+                    "run_id": os.getenv("APP_RUN_ID", "unknown"),
+                    "stage": "validate_basic_inputs",
+                    "validation_pass": False,
+                    "reason_code": reason,
+                    "fields_seen": list(polymarket_contract.keys()),
+                    "pm_market_id": polymarket_contract.get("id") or polymarket_contract.get("question_id") or polymarket_contract.get("slug"),
+                    "pm_question": polymarket_contract.get("question"),
+                    "pm_currency_field": polymarket_contract.get("currency"),
+                })
+                return False
+        
+        # Check spot price only if it's relevant for the strategy
+        if 'strike_price' in self.REQUIRED_FIELDS and current_spot <= 0:
+            self.logger.debug(f"Invalid spot price: {current_spot}")
+            _audit_emit({
+                "run_id": os.getenv("APP_RUN_ID", "unknown"),
+                "stage": "validate_basic_inputs",
+                "validation_pass": False,
+                "reason_code": "BAD_SPOT",
+                "current_spot": current_spot,
+            })
+            return False
+            
+        return True
+    
+    def _validate_position_price(self, position: str, price: Optional[float]) -> bool:
+        """
+        Validate price for a specific position (YES or NO).
+        
+        For YES positions: reject if YES price is too low or too high
+        For NO positions: reject if NO price is too low or too high
+        
+        This allows taking NO positions when YES is extreme and vice versa.
+        """
+        if price is None:
+            return False
+        
+        price = float(price)
+        if not (0.0 < price < 1.0):
+            return False
+        
+        # Use existing thresholds from base class or defaults
+        min_threshold = getattr(self, 'min_price_threshold', 0.01)  # 1% minimum
+        max_threshold = getattr(self, 'max_price_threshold', 0.99)  # 99% maximum
+        
+        if price < min_threshold:
+            self.logger.debug(f"{position} price too low for liquidity: {price:.3f} < {min_threshold}")
+            return False
+        
+        if price > max_threshold:
+            self.logger.debug(f"{position} price too high for liquidity: {price:.3f} > {max_threshold}")
+            return False
+        
+        return True
+    
     def evaluate_opportunities(
         self,
         polymarket_contract: Dict,
@@ -509,8 +580,9 @@ class VarianceSwapStrategy(BaseOptionsStrategy):
         except Exception:
             pass
             
-        if not self.validate_inputs(polymarket_contract, current_spot):
+        # Only validate basic requirements here, not prices
+        if not self._validate_basic_inputs(polymarket_contract, current_spot):
             try:
                 with open(debug_log_path, "a") as f:
                     f.write(f"  - VALIDATION FAILED\n")
             except Exception:
@@ -600,22 +672,44 @@ class VarianceSwapStrategy(BaseOptionsStrategy):
             self.logger.debug(f"[variance] expiry={expiry_date}: raw options={len(expiry_options)}, unique strikes={len(set(o['strike'] for o in expiry_options))}")
             # Let the portfolio builder enforce grid adequacy; don't pre-filter here
             
-            # Evaluate YES position with variance hedge
-            yes_opportunity = self._evaluate_variance_hedge(
-                'YES', yes_price, pm_strike,
-                expiry_date, expiry_options, current_spot,
-                position_size, polymarket_contract, vol_sensitivity
-            )
-            if yes_opportunity:
-                opportunities.append(yes_opportunity)
+            # Evaluate YES position only if YES price passes validation
+            if self._validate_position_price('YES', yes_price):
+                yes_opportunity = self._evaluate_variance_hedge(
+                    'YES', yes_price, pm_strike,
+                    expiry_date, expiry_options, current_spot,
+                    position_size, polymarket_contract, vol_sensitivity
+                )
+                if yes_opportunity:
+                    opportunities.append(yes_opportunity)
+            else:
+                self.logger.debug(f"[variance] Skipping YES position: price {yes_price} outside valid range [{getattr(self, 'min_price_threshold', 0.01)}, {getattr(self, 'max_price_threshold', 0.99)}]")
+                _audit_emit({
+                    "run_id": os.getenv("APP_RUN_ID", "unknown"),
+                    "stage": "position_validation",
+                    "position": "YES",
+                    "validation_pass": False,
+                    "yes_price": yes_price,
+                    "pm_question": polymarket_contract.get("question"),
+                })
             
-            # Evaluate NO position with variance hedge
-            no_opportunity = self._evaluate_variance_hedge(
-                'NO', no_price, pm_strike,
-                expiry_date, expiry_options, current_spot,
-                position_size, polymarket_contract, vol_sensitivity
-            )
-            if no_opportunity:
-                opportunities.append(no_opportunity)
+            # Evaluate NO position only if NO price passes validation
+            if self._validate_position_price('NO', no_price):
+                no_opportunity = self._evaluate_variance_hedge(
+                    'NO', no_price, pm_strike,
+                    expiry_date, expiry_options, current_spot,
+                    position_size, polymarket_contract, vol_sensitivity
+                )
+                if no_opportunity:
+                    opportunities.append(no_opportunity)
+            else:
+                self.logger.debug(f"[variance] Skipping NO position: price {no_price} outside valid range [{getattr(self, 'min_price_threshold', 0.01)}, {getattr(self, 'max_price_threshold', 0.99)}]")
+                _audit_emit({
+                    "run_id": os.getenv("APP_RUN_ID", "unknown"),
+                    "stage": "position_validation",
+                    "position": "NO",
+                    "validation_pass": False,
+                    "no_price": no_price,
+                    "pm_question": polymarket_contract.get("question"),
+                })
         
         return opportunities