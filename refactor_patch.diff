diff --git a/hedging/options.py b/hedging/options.py
index 0000000..1111111 100644
--- a/hedging/options.py
+++ b/hedging/options.py
@@ -1,10 +1,18 @@
 from __future__ import annotations
 from typing import Protocol, Mapping, Any, Dict, Iterable, Optional, List, Tuple
 import logging
 from dataclasses import dataclass
 from strategies.tag_router import StrategyTagRouter
 from digital_hedge_builder import build_digital_vertical_at_K
+from datetime import datetime, date, timezone
+from copy import deepcopy
+from core.expiry_window import enumerate_expiries, pm_date_to_default_cutoff_utc
@@
 class OptionHedgeBuilder:
@@
     def __init__(self, scanners: Dict[str, Dict[str, Any]], market_analyzer: Optional[Any] = None, logger: Optional[logging.Logger] = None) -> None:
         self.scanners = scanners or {}
         self.market_analyzer = market_analyzer or MarketDataAnalyzer()
         self.logger = logger or logging.getLogger(self.__class__.__name__)
         # Write one consumer-side checkpoint only (single JSON per run)
         self._consumer_checkpoint_written = False
+        # Exposed for Orchestrator to write unfiltered_opportunities_*.json
+        self.unfiltered_opportunities: List[Dict[str, Any]] = []
 
@@
-    def build(self, _market_snapshot: Mapping[str, Any]) -> Iterable[Dict[str, Any]]:
+    def build(self, _market_snapshot: Mapping[str, Any]) -> Iterable[Dict[str, Any]]:
         opportunities: List[Dict[str, Any]] = []
         debugger = get_step_debugger()
 
         for currency, scanner in self.scanners.items():
             contracts = scanner.get('contracts') or []
             if not contracts:
                 continue
@@
-            # ---- Strategy routing by tags (options.XXX) ----
-            # Build instrument universe once per contract
-            hedge_instruments: Dict[str, Any] = {}
+            # ---- Build instrument universe once per contract ----
+            hedge_instruments: Dict[str, Any] = {}
             oc = scanner.get('options_collector')
             if scanner.get('has_options') and oc:
                 try:
                     all_options = oc.get_all_options() or []
                     hedge_instruments["options"] = all_options
@@
-            # Derive dynamic sizing
+            # Derive dynamic sizing
             position_size = self._calculate_liquidity_based_position_size(contract, hedge_instruments)
 
-            # Collect hierarchical strategy tags; fallback to legacy names
+            # Collect hierarchical strategy tags; fallback to legacy names
             tags: List[str] = list(contract.get("strategyTags") or [])
             if not tags:
                 legacy = [str(s) for s in (contract.get("strategies") or [])]
                 if "variance_swap" in legacy:
                     tags.append("options.variance_swap")
             # Gate options.variance_swap to SINGLE_THRESHOLD markets only
             if "options.variance_swap" in tags and str(contract.get("marketClass")).upper() != "SINGLE_THRESHOLD":
                 tags = [t for t in tags if t != "options.variance_swap"]
 
             if tags:
                 router = StrategyTagRouter()
                 strategy_instances = router.instantiate_for_tags(
                     [t for t in tags if t.startswith("options.")],
                     risk_free_rate=RISK_FREE_RATE,
                     cfg=get_config(),
                 )
             else:
                 strategy_instances = []
 
-            produced_by_strategy = False
+            produced_by_strategy = False
+
+            # -------- NEW: canonical PM settlement timestamp (date-only → 23:59:59Z) --------
+            def _parse_pm_settlement_ts(pm: Dict[str, Any]) -> Optional[datetime]:
+                # Prefer explicit timestamp if present
+                for k in ("end_date", "endDate"):
+                    v = pm.get(k)
+                    if v:
+                        try:
+                            ts = datetime.fromisoformat(str(v).replace("Z", "+00:00"))
+                            return ts if ts.tzinfo else ts.replace(tzinfo=timezone.utc)
+                        except Exception:
+                            pass
+                # Fallback: date-only field
+                d = pm.get("polymarket_date") or pm.get("pm_date") or pm.get("date")
+                if isinstance(d, date) and not isinstance(d, datetime):
+                    return pm_date_to_default_cutoff_utc(d)
+                if isinstance(d, str) and len(d) >= 10:
+                    try:
+                        y, m, dd = int(d[0:4]), int(d[5:7]), int(d[8:10])
+                        return pm_date_to_default_cutoff_utc(date(y, m, dd))
+                    except Exception:
+                        pass
+                return None
+
+            pm_ts = _parse_pm_settlement_ts(contract)
+            # If PM ts is unknown, we cannot compute DTE accurately; still run (enumerator will keep >=0h default if ts exists)
+            all_options = hedge_instruments.get("options") or []
+            # Build policy_cfg from config (mirrors core defaults with your variance overrides)
+            try:
+                cfg = get_config()
+                hedging = getattr(cfg, "hedging", None)
+                varcfg = getattr(hedging, "variance", None)
+                policy_cfg = dict(
+                    expiry_policy=getattr(varcfg, "expiry_policy", "allow_far_with_unwind"),
+                    max_expiry_gap_days=getattr(varcfg, "max_expiry_gap_days", 60),
+                    max_expiries_considered=getattr(varcfg, "max_expiries_considered", 10),
+                    min_quotes_per_expiry=getattr(varcfg, "min_quotes_per_expiry", 2),
+                    min_strikes_required=getattr(varcfg, "min_strikes_required", 6),
+                )
+            except Exception:
+                policy_cfg = dict(
+                    expiry_policy="allow_far_with_unwind",
+                    max_expiry_gap_days=60,
+                    max_expiries_considered=10,
+                    min_quotes_per_expiry=2,
+                    min_strikes_required=6,
+                )
+
+            # Enumerate expiries (if pm_ts is known). If unknown, treat as single-bucket (no per-expiry split).
+            candidates = enumerate_expiries(pm_ts, all_options, policy_cfg=policy_cfg) if pm_ts else []
+            try:
+                debugger.checkpoint("expiry_candidates_for_contract", {
+                    "contract": (contract.get("question") or contract.get("id")),
+                    "pm_ts": pm_ts.isoformat() if pm_ts else None,
+                    "num_candidates": len(candidates),
+                    "candidates": [ {"expiry": c.date.isoformat(), "dte_hours": c.dte_hours, "quotes": c.quotes, "strikes": c.strikes} for c in candidates ],
+                })
+            except Exception:
+                pass
+
+            def _filter_to_expiry_date(options: List[dict], d: date) -> List[dict]:
+                allowed = d.isoformat()
+                out: List[dict] = []
+                for o in options or []:
+                    e = o.get("expiry") or o.get("expiry_date") or o.get("expiration")
+                    dd = None
+                    if isinstance(e, str):
+                        dd = e[:10]
+                    elif isinstance(e, date) and not isinstance(e, datetime):
+                        dd = e.isoformat()
+                    elif isinstance(e, datetime):
+                        dd = e.date().isoformat()
+                    if dd == allowed:
+                        out.append(o)
+                return out
+
+            # Helper: attach expiry metadata to every produced opportunity
+            def _attach_expiry_meta(opp: Dict[str, Any], cand) -> None:
+                try:
+                    opp["option_expiry"] = cand.date.isoformat()
+                    opp["option_expiry_ts"] = cand.expiry_ts_utc.isoformat()
+                    opp["option_dte_days"] = float(cand.dte_hours) / 24.0
+                except Exception:
+                    pass
 
             if strategy_instances:
                 current_spot = float(scanner.get('current_spot') or 0.0)
-                for strat in strategy_instances:
-                    try:
-                        opps = strat.evaluate_opportunities(
-                            polymarket_contract=contract,
-                            hedge_instruments=hedge_instruments,
-                            current_spot=current_spot,
-                            position_size=position_size,
-                        ) or []
-                    except Exception as e:
-                        self.logger.debug("Strategy %s failed: %s", getattr(strat, "__class__", type(strat)).__name__, e)
-                        continue
-                    for opp in opps:
+                for strat in strategy_instances:
+                    # Route through the shared enumerator: call the strategy once per expiry candidate.
+                    per_strat_opps: List[Dict[str, Any]] = []
+                    if candidates:
+                        for cand in candidates:
+                            hedg_exp = dict(hedge_instruments)
+                            hedg_exp["options"] = _filter_to_expiry_date(all_options, cand.date)
+                            if not hedg_exp["options"]:
+                                continue
+                            try:
+                                opps = strat.evaluate_opportunities(
+                                    polymarket_contract=contract,
+                                    hedge_instruments=hedg_exp,
+                                    current_spot=current_spot,
+                                    position_size=position_size,
+                                ) or []
+                            except Exception as e:
+                                self.logger.debug("Strategy %s failed at %s: %s",
+                                                  getattr(strat, "__class__", type(strat)).__name__,
+                                                  cand.date.isoformat(), e)
+                                continue
+                            for opp in opps:
+                                _attach_expiry_meta(opp, cand)
+                                per_strat_opps.append(opp)
+                    else:
+                        # No pm_ts (or no candidates) → run once without per-expiry split
+                        try:
+                            opps = strat.evaluate_opportunities(
+                                polymarket_contract=contract,
+                                hedge_instruments=hedge_instruments,
+                                current_spot=current_spot,
+                                position_size=position_size,
+                            ) or []
+                        except Exception as e:
+                            self.logger.debug("Strategy %s failed: %s", getattr(strat, "__class__", type(strat)).__name__, e)
+                            opps = []
+                        per_strat_opps.extend(opps)
+
+                    for opp in per_strat_opps:
                         # Standard metadata
                         opp.setdefault("currency", currency)
                         opp.setdefault("hedge_type", "options")
                         opp.setdefault("strategy", getattr(strat, "__class__", type(strat)).__name__)
@@
                         opportunities.append(opp)
                 produced_by_strategy = True
 
             if produced_by_strategy:
                 # Already produced opportunities via strategy routing; skip generic digital construction
                 continue
@@
-            # Checkpoint: Raw hedge opportunities before ranking
+            # -------- Capture UNFILTERED opportunities BEFORE ranking/EV filter --------
+            try:
+                # Deep copy to freeze pre-filter view for the Orchestrator writer
+                self.unfiltered_opportunities = deepcopy(opportunities)
+            except Exception:
+                # Fallback: shallow copy is better than nothing
+                self.unfiltered_opportunities = list(opportunities)
+
+            # Checkpoint: Raw hedge opportunities before ranking
             debugger.checkpoint("hedge_opportunities_raw", opportunities, {"count": len(opportunities), "currencies": list(set(o.get("currency") for o in opportunities)), "strategies": list(set(o.get("strategy") for o in opportunities))})
 
             # Rank + filter
             if opportunities:
@@
-            # Checkpoint: Final hedge opportunities with expiry information
+            # Checkpoint: Final hedge opportunities with expiry information
             try:
                 # Collect expiry statistics
                 expiry_counts = {}
                 opportunities_with_expiry = 0
                 for opp in opportunities:
                     if opp.get('option_expiry'):
                         opportunities_with_expiry += 1
                         expiry = opp['option_expiry']
                         expiry_counts[expiry] = expiry_counts.get(expiry, 0) + 1
                 debugger.checkpoint("hedge_opportunities_with_expiry", opportunities, {"count": len(opportunities), "with_expiry": opportunities_with_expiry, "unique_expiries": len(expiry_counts), "expiry_distribution": expiry_counts})
             except Exception:
                 pass
             return opportunities